{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#spriggit","title":"Spriggit","text":""},{"location":"#overview","title":"Overview","text":"<p>Spriggit is a tool to facilitate converting Bethesda plugin files to a text based format that can be stored in Git. Large scale projects can then live in Github, and accept Pull Requests from many developers.</p> <p>The goal is to help modders store their files in a versioning system that allows them to easily iterate in the same way that programmers do with their code.</p> <p></p>"},{"location":"#reasons-to-use-git-for-mods","title":"Reasons to Use Git for Mods","text":"<p>Git is an extremely powerful versioning and iteration tool that almost all programmers use when working.  It's what powers the world of coding to be able to iterate new code quickly and collaborate easily.  </p> <p>Some things Git can help you do when developing your mod:</p> <ul> <li>Keep track of the many versions of your mod, without resorting to Dropbox folder hell.</li> <li>Create a living \"changelog\" as you work</li> <li>Be able to go back in time and view your mod exactly as it was at any point in history</li> <li>Stamp your mod with version tags, letting you see how it looked at any one from the past</li> <li>Easily experiment on side branches without worrying your stable setup</li> <li>Share your work on Github, allowing people to see your mod's development progress</li> <li>Collaborate easily, by allowing others to contribute to your mod via Pull Requests</li> <li>More easily merge the work of multiple developers with Git Merge technology</li> </ul> <p> </p>"},{"location":"alpha-backwards-compatibility/","title":"Backwards Compatibility With Alpha Versions","text":""},{"location":"alpha-backwards-compatibility/#backwards-compatibility-with-early-alpha-versions","title":"Backwards Compatibility with Early Alpha Versions","text":"<p>The systems for which Spriggit obtains the code to be used when deserializing older versions of Spriggit has been modified heavily since its early days.</p> <p><code>v0.20</code> introduced a few newer concepts, and is a \"bridge\" version that contains the old logic and the new logic.</p> <p>If you have spriggit content that you want to decode from versions before <code>v0.20</code>, it is recommended that you download <code>v0.20</code> and attempt to do so with that.  Newer versions will not have the logic needed to decode ancient setups.</p> <p>If you still have issues, swing by the discord, and we'll make sure your files get decoded one way or the other:</p> <p></p>"},{"location":"backups/","title":"Backups","text":""},{"location":"backups/#backups","title":"Backups","text":"<p>Spriggit does a lot of transformations to get a Bethesda Plugin to a Git compatible text based format.  In an ideal world, you no longer need to keep your older Bethesda Plugins, as you can always go back in history and reconstitute one from the Git contents.  However, in doing so, you're putting a lot of trust in Spriggit that it can do that successfully, otherwise you're left with a bunch of text files and no actual plugin your game can run.  </p> <p>While this hopefully never happens, it's always good to have a backup plan (especially as Spriggit is still in beta)</p>"},{"location":"backups/#timed-backups","title":"Timed Backups","text":"<p>Spriggit currently backs up Bethesda Plugins every time it does a deserialize call.  These are stored in `%temp%/Spriggit/Backups/[Mod Name]/[Date of Backup]/</p> <p>It will do some optimization, like not re-backing up the file if the contents are the same as the previous.  </p> <p>Backups are stored for 30 days by default, at which point older ones are cleared out.</p>"},{"location":"backups/#future-work","title":"Future Work","text":"<p>More work might be put into the backup system, including easier ways to restore via CLI/UI, or mechanisms for storing backups in the Git repo itself.</p>"},{"location":"bad-target-folder/","title":"Bad Target Folder","text":""},{"location":"bad-target-folder/#bad-target-folder","title":"Bad Target Folder","text":"<p>\"Cannot export next to a .git folder\"</p> <p>Spriggit's patterns require that you serialize into a folder that is wholly dedicated to containing Spriggit content.   As part of the serialization process, all files within that folder that were not just exported get deleted.   As such, if you're exporting spriggit content into a folder containing other files, they will be deleted as part of the serialization process.</p>"},{"location":"bad-target-folder/#solution","title":"Solution","text":"<p>Simply make a new dedicated subfolder named after the mod and target that instead.</p> <pre><code>/Some Folder\n   Other Content.txt\n   MyMod.esp/\n</code></pre> <p>In this case, you would not want to target <code>/Some Folder</code>, as that has <code>Other Content.txt</code> within it.   Rather, targeting a subfolder with nothing else is recommended.</p>"},{"location":"cli/","title":"Command Line Interface","text":""},{"location":"cli/#command-line-interface","title":"Command Line Interface","text":"<p>Spriggit comes with a Command Line Interface that can be used to convert from Betheseda Plugins to Git Repositories, and back. </p> <p>These commands have parameters that are optional only if a .spriggit file is found.</p> <p> .spriggit File</p>"},{"location":"cli/#serialize-convert-from-plugin","title":"Serialize | Convert From Plugin","text":"<p><code>serialize</code>, or <code>convert-from-plugin</code></p> <p>This converts from a Bethesda Plugin mod to Yaml, and puts it in your Git Repository.</p>"},{"location":"cli/#typical","title":"Typical","text":"<p><code>.\\Path\\To\\Spriggit.CLI.exe convert-from-plugin --InputPath \"C:\\Games\\steamapps\\common\\Skyrim Special Edition\\Data\\SomeMod.esp\" --OutputPath \"C:\\MyGitRepository\\SomeMod.esp\" --GameRelease SkyrimSE --PackageName Spriggit.Yaml</code></p>"},{"location":"cli/#parameters","title":"Parameters","text":"Short Long Required Description <code>-i</code> <code>--InputPath</code> Required Path to the Bethesda plugin (esp/esm) <code>-o</code> <code>--OutputPath</code> Required Dedicated folder to export mod as its text representation <code>-g</code> <code>--GameRelease</code> Semi-Optional Game release that the plugin is related to.  Required if no <code>.spriggit</code> file is found. <code>-p</code> <code>--PackageName</code> Semi-Optional Spriggit serialization nuget package name to use for conversion.  Required if no <code>.spriggit</code> file is found. <code>-v</code> <code>--PackageVersion</code> Optional Spriggit serialization nuget package version to use for conversion <code>-t</code> <code>--Threads</code> Optional Maximum number of threads to use <code>-d</code> <code>--DataFolder</code> Semi-Optional Provides a path to the data folder for reference.  Read More <code>-u</code> <code>--ErrorOnUnknown</code> Optional (default True).  If on, will error out if any unknown records that are encountered <code>--Debug</code> Optional Set up for debug mode, including resetting nuget caches <p>Must Have Dedicated Folder</p> <p>Make sure the output path is pointed to a folder which is -wholly- dedicated to containing Spriggit content.   More Info</p> <p>Starfield</p> <p>Starfield must supply Master Style Input</p> <p>The valid list of GameReleases are listed here but are generally as follows:</p> <ul> <li>Oblivion</li> <li>OblivionRE</li> <li>SkyrimLE</li> <li>SkyrimSE</li> <li>SkyrimVR</li> <li>Fallout4</li> <li>Fallout4VR</li> <li>SkyrimSEGog</li> <li>Starfield</li> </ul> <p><code>PackageName</code> and <code>PackageVersion</code> are both driven by what Translation Package you want to use to do the translation.  Each translation is a NuGet package with a name and a version, which you specify in the appropriate fields.  For the built in Spriggit Translation Packages <code>Spriggit.Yaml</code> and <code>Spriggit.Json</code>, the <code>.[GameName]</code> suffix can be omitted, as it's implied by the GameRelease parameter.   For non-standard 3rd party packages, the full NuGet package name is required.</p>"},{"location":"cli/#deserialize-convert-to-plugin","title":"Deserialize | Convert To Plugin","text":"<p><code>deserialize</code>, <code>convert-to-plugin</code>, <code>create-plugin</code></p> <p>This converts from a folder in your Git Repository to a Bethesda Plugin.</p>"},{"location":"cli/#typical_1","title":"Typical","text":"<p><code>.\\Path\\To\\Spriggit.CLI.exe convert-to-plugin --InputPath \"C:\\Users\\Levia\\Downloads\\SpriggitOutput\\SomeMod.esp\" --OutputPath \"C:\\MyGitRepository\\SomeMod.esp\"</code></p>"},{"location":"cli/#parameters_1","title":"Parameters","text":"Short Long Required Description <code>-i</code> <code>--InputPath</code> Required Path to the Bethesda plugin folder as its Spriggit text representation <code>-o</code> <code>--OutputPath</code> Required Path to export the mod as its Bethesda plugin representation <code>-p</code> <code>--PackageName</code> Optional Spriggit serialization nuget package name to use for conversion.  Leave blank to auto detect <code>-v</code> <code>--PackageVersion</code> Optional Spriggit serialization nuget package version to use for conversion.  Leave blank to auto detect <code>-t</code> <code>--Threads</code> Optional Maximum number of threads to use <code>-d</code> <code>--DataFolder</code> Semi-Optional Provides a path to the data folder for reference.  Read More <code>--Debug</code> Optional Set up for debug mode, including resetting nuget caches <code>-b</code> <code>--BackupDays</code> Optional Days to keep backup plugins in the temp folder (default 30) <p>Omit Package Details</p> <p>Spriggit stores the package details it was created with, so in most circumstances, you want to let it automatically detect the package information.</p> <p>Starfield</p> <p>Starfield must supply Master Style Input</p> <p> Backups</p>"},{"location":"cli/#upgrade-spriggit-version","title":"Upgrade Spriggit Version","text":"<p><code>upgrade</code></p> <p>This command upgrades existing Spriggit files to a newer package version. It deserializes the mod files using the current version, updates the spriggit-meta.json to the specified version, and re-serializes the files with the new translation package.</p>"},{"location":"cli/#typical_2","title":"Typical","text":"<p><code>.\\Path\\To\\Spriggit.CLI.exe upgrade -p \"C:\\MyGitRepository\\SomeMod.esp\\\" -v \"1.2.3\"</code></p>"},{"location":"cli/#parameters_2","title":"Parameters","text":"Short Long Required Description <code>-p</code> <code>--SpriggitPath</code> Required Path to the Bethesda plugin folder as its Spriggit text representation <code>-v</code> <code>--PackageVersion</code> Required Spriggit serialization nuget package version to upgrade to <code>-d</code> <code>--DataFolder</code> Semi-Optional Path to the data folder for reference. Read More <code>-s</code> <code>--SkipGitOperations</code> Optional Skip git operations (don't check for uncommitted changes or auto-commit) <p>Backup Recommended</p> <p>It's recommended to backup your Spriggit files before upgrading, as the process involves deserializing and re-serializing your mod data.</p> <p>Git Integration</p> <p>By default, the upgrade command checks for uncommitted changes before starting and automatically commits the upgrade changes when complete. Use <code>--SkipGitOperations</code> to disable this behavior if you want to manage git operations manually.</p> <p>Starfield</p> <p>Starfield must supply Master Style Input</p>"},{"location":"cli/#formid-collision-fixing","title":"FormID Collision Fixing","text":"<p><code>formid-collision</code></p> <p>This command helps detangle colliding FormIDs that result after a Git Merge.</p> <p> FormID Collision</p> <p>Two Collisions Maximum</p> <p>The logic that Spriggit contains to handle FormID conflicts can only handle two records with a single FormID.  As such, collisions need to be handled immediately after each Git merge.</p>"},{"location":"cli/#typical_3","title":"Typical","text":"<p><code>.\\Path\\To\\Spriggit.CLI.exe formid-collision -p \"C:\\MyGitRepository\\SomeMod.esp\\\"</code></p>"},{"location":"cli/#parameters_3","title":"Parameters","text":"Short Long Required Description <code>-p</code> <code>--SpriggitPath</code> Required Path to the Bethesda plugin folder as its Spriggit text representation <code>-d</code> <code>--Debug</code> Optional Set up for debug mode, including resetting nuget caches"},{"location":"cli/#master-style-input","title":"Master Style Input","text":"<p>Newer games, like Starfield, require extra inputs in order to translate.  These games need information from the source files of every master they list in a way that older games do not.  As such, you either need to provide:</p> <ul> <li><code>-d</code> <code>--DataFolder</code> parameter pointing to a folder containing all of the master files, for reference.</li> <li><code>Known Masters</code> within a <code>.spriggit</code> file</li> </ul> <p>For command lines running as part of CI processes on servers without game information, the Known Master system can often be preferable to actually having the master files on hand.</p>"},{"location":"filename-too-long/","title":"Filename Too Long","text":""},{"location":"filename-too-long/#filename-too-long","title":"Filename Too Long","text":"<p>\"Filename too long\" or similar path length errors when working with Spriggit output.</p> <p>When Spriggit converts Bethesda plugins to text format, it creates detailed folder structures that can result in very long file paths. On Windows, the default path length limit is 260 characters, which can easily be exceeded when dealing with complex mod structures that include nested folders and descriptive filenames.</p>"},{"location":"filename-too-long/#common-error-messages","title":"Common Error Messages","text":"<ul> <li>\"The specified path, file name, or both are too long\"</li> <li>\"Filename too long\"</li> <li>Git operations failing with path length errors</li> <li>Unable to clone or checkout repositories with Spriggit content</li> </ul>"},{"location":"filename-too-long/#solution","title":"Solution","text":"<p>Configure Git to handle long paths by running this command in your terminal:</p> <pre><code>git config --global core.longpaths true\n</code></pre> <p>This enables Git to work with paths longer than 260 characters on Windows.</p>"},{"location":"filename-too-long/#alternative-per-repository-configuration","title":"Alternative: Per-Repository Configuration","text":"<p>If you prefer to enable long paths only for specific repositories:</p> <pre><code>git config core.longpaths true\n</code></pre> <p>Run this command from within the specific Git repository where you're working with Spriggit content.</p>"},{"location":"filename-too-long/#additional-windows-configuration","title":"Additional Windows Configuration","text":"<p>In some cases, you may also need to enable long path support at the Windows system level:</p> <ol> <li>Open Group Policy Editor (<code>gpedit.msc</code>) as Administrator</li> <li>Navigate to: <code>Computer Configuration &gt; Administrative Templates &gt; System &gt; Filesystem</code></li> <li>Enable \"Enable Win32 long paths\"</li> <li>Restart your computer</li> </ol> <p>Alternatively, you can enable this via the Windows Registry by setting <code>HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem\\LongPathsEnabled</code> to <code>1</code>.</p>"},{"location":"filename-too-long/#prevention","title":"Prevention","text":"<p>To minimize path length issues:</p> <ul> <li>Keep your Git repository closer to the root of your drive (e.g., <code>C:\\Projects\\MyMod</code> instead of <code>C:\\Users\\Username\\Documents\\Very\\Deep\\Folder\\Structure\\MyMod</code>)</li> <li>Use shorter mod names when possible</li> <li>Consider the total path length when organizing your project structure</li> </ul>"},{"location":"filename-too-long/#why-this-happens","title":"Why This Happens","text":"<p>Spriggit creates organized folder structures that mirror the hierarchical nature of Bethesda plugin data. Records are sorted into folders by type, and individual records get their own files with descriptive names. This organization makes the content more Git-friendly but can result in deeply nested paths that exceed Windows' default limitations.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#install-latest-net-sdk","title":"Install Latest .NET SDK","text":"<p>You can get the typical SDK installation from Microsoft's official page</p> <p> Download SDK</p> <p>Restart</p> <p>It's usually a good idea to restart your computer after installing DotNet SDK to help things settle in.</p> <p>This step is needed by the \"engine\" in order to download the Spriggit translation packages via <code>dotnet tool install</code>.  More info here.</p>"},{"location":"installation/#download-spriggit-exe","title":"Download Spriggit Exe","text":"<p>Spriggit comes as a UI and a Command Line Interface.   Both can be downloaded from the github releases page</p> <p> Download</p>"},{"location":"installation/#spriggit-ui","title":"Spriggit UI","text":"<p>This is a self-contained WPF application, which can only run on Windows.  You can add links between a mod file and where it should be translated to, and then sync back and forth with one click.</p> <p> </p>"},{"location":"installation/#spriggit-cli","title":"Spriggit CLI","text":"<p>Spriggit comes with a Command Line Interface that can be used to convert from Betheseda Plugins to Git Repositories, and back.   </p> <p>UI Can Also Run as a CLI</p> <p>The UI executable can also be run as a command line interface.</p> <p>For more details on the various commands that can be run:</p> <p> Command Line Interface</p>"},{"location":"merge-conflicts/","title":"Merge Conflicts","text":""},{"location":"merge-conflicts/#merge-conflicts","title":"Merge Conflicts","text":"<p>One of the powerful concepts that Spriggit + Git opens up is the ability to work on several branches in parallel.   Inevitably, this work needs to be merged together at some point, which can result in merge conflicts.</p>"},{"location":"merge-conflicts/#typical-content-conflicts","title":"Typical Content Conflicts","text":"<p>Merge conflicts are normal, but do need to be dealt with when they arise.  Typically this will arise if two sides modified the same fields on a record, where it's unsure which change you wanted to keep in the final result.</p> <p>You can google more about general Git merge conflict handling</p> <p> Git Merge Conflicts</p>"},{"location":"merge-conflicts/#formid-collision","title":"FormID Collision","text":"<p>A concept that is unique to Bethesda mods and Spriggit is when FormIDs collide.</p> <p>When new records are added, a FormID is claimed.   If two people working in parallel create a new record, then they both might claim the same FormID.   When merging their changes, this results in a duplicate FormID within the mod, which is not allowed.</p> <p>This will not result in a typical Git Merge Conflict, but it something to check for and fix after every merge.</p>"},{"location":"merge-conflicts/#fixing-formid-collision","title":"Fixing FormID Collision","text":"<p>Spriggit comes with tooling to detect and fix these FormID collisions.  It is recommended to do this after every merge.</p> <p> CLI Command</p> <p>This tool fixes the FormID collisions by modifying one of the records involved in the collision to have a new FormID, and also rerouting any reference to it within the mod to point to that new record.</p> <p>Here is an example of some work being done in parallel, where one side added an Npc, and the other a Weapon, both of which would have claimed the same FormID:</p> <p></p> <p>After running the tool, an extra commit adjusting one of the records has been added and merged in to de-collide the records:</p> <p></p> <p>Two Collisions Maximum</p> <p>The logic that Spriggit contains to handle FormID conflicts can only handle two records with a single FormID.  As such, collisions need to be handled immediately after each Git merge.</p>"},{"location":"omissions/","title":"Omissions","text":""},{"location":"omissions/#omissions","title":"Omissions","text":""},{"location":"omissions/#overview","title":"Overview","text":"<p>The Creation Kit sometimes writes junk or unused data into certain fields when saving plugin files. These fields contain no meaningful information and can vary between saves even when you haven't made any changes. Spriggit automatically omits these known problematic fields to prevent unnecessary differences in your Git history.</p>"},{"location":"omissions/#why-omissions-matter","title":"Why Omissions Matter","text":"<p>When working with Git and tracking changes to your mod:</p> <ul> <li>Cleaner Diffs: Omitting junk data ensures your diffs only show actual changes you made, not random bytes the Creation Kit wrote</li> <li>Meaningful History: Your Git history reflects intentional modifications, not Creation Kit artifacts</li> <li>Smaller Files: Excluding unused fields reduces the size of your serialized mod files</li> <li>Reduced Conflicts: Preventing junk data changes minimizes false merge conflicts that would otherwise occur from random byte differences</li> </ul>"},{"location":"omissions/#what-gets-omitted","title":"What Gets Omitted","text":"<p>Spriggit automatically omits several categories of fields that are known to contain junk or unnecessary data:</p>"},{"location":"omissions/#unused-fields","title":"Unused Fields","text":"<p>Many record types contain fields explicitly marked as \"Unused\" in the game's data structures. These fields serve no purpose and the Creation Kit may write arbitrary data into them. Examples include:</p> <ul> <li>Unused condition parameters: Condition records have unused data fields that vary randomly</li> <li>PlayerSkills.Unused: Padding bytes in Skyrim NPC player skill data</li> <li>Other record-specific unused fields</li> </ul>"},{"location":"omissions/#unknowninternal-data","title":"Unknown/Internal Data","text":"<p>Some fields contain internal Creation Kit metadata that isn't relevant for version control:</p> <ul> <li>Unknown group header data: Binary metadata in group headers that changes between saves</li> <li>Timestamp data: When records were last modified in the Creation Kit (not your actual mod changes)</li> <li>Last modified data: Internal tracking information</li> </ul>"},{"location":"omissions/#condition-data-fields","title":"Condition Data Fields","text":"<p>Conditions have several data fields that are only used for specific function types. When a condition uses a function that doesn't need certain parameters, those parameter fields may contain leftover junk data. Spriggit omits unused condition data fields to prevent this junk from appearing in diffs.</p>"},{"location":"omissions/#how-omissions-work","title":"How Omissions Work","text":"<p>Omitted fields are:</p> <ul> <li>Not written during serialization (Spriggit \u2192 YAML/JSON)</li> <li>Set to default values during deserialization (YAML/JSON \u2192 Spriggit)</li> </ul> <p>This means when you serialize a mod, omitted fields won't appear in your YAML/JSON files. When you deserialize back to a plugin, these fields will be set to safe default values (typically zeros or empty arrays).</p>"},{"location":"omissions/#reporting-issues","title":"Reporting Issues","text":"<p>If you encounter problems with omissions:</p>"},{"location":"omissions/#fields-that-should-be-omitted","title":"Fields That Should Be Omitted","text":"<p>If you notice fields that contain junk data and cause unnecessary diffs between saves (when you haven't actually changed anything), please report them to the Spriggit GitHub repository.</p> <p>When reporting:</p> <ol> <li>Specify which game (Skyrim, Fallout 4, etc.)</li> <li>Identify the record type (Quest, NPC, Condition, etc.)</li> <li>Note which specific field contains junk data</li> <li>Describe how you verified it's junk (e.g., \"appears as changed in Git after re-saving without modifications\")</li> </ol>"},{"location":"omissions/#fields-being-omitted-that-shouldnt-be","title":"Fields Being Omitted That Shouldn't Be","text":"<p>If you find that Spriggit is omitting a field that actually contains important data you need to preserve, please report this as well:</p> <ol> <li>Specify which game and record type</li> <li>Identify which field is being omitted</li> <li>Explain what data it should contain and why it's important</li> <li>Provide an example of how the omission causes problems</li> </ol> <p>This helps improve Spriggit for everyone by ensuring the right balance between omitting junk and preserving meaningful data.</p>"},{"location":"output/","title":"Output","text":""},{"location":"output/#output","title":"Output","text":"<p>Spriggit processes Bethesda plugins into a format that Git can support.</p>"},{"location":"output/#example-record-output","title":"Example Record Output","text":"<p>Yaml or Json</p> <p>Yaml or Json formatting is currently supported</p> <p>Here is a snippet of what a record file might look like if Yaml output is used: </p><pre><code>FormKey: 087835:Skyrim.esm\nEditorID: JewelryNecklaceGoldGems\nObjectBounds:\n  First: -3, -9, 0\n  Second: 3, 9, 1\nName: Gold Jeweled Necklace\nWorldModel:\n  Male:\n    Model:\n      File: Armor\\AmuletsandRings\\GoldAmuletGemsGO.nif\n      Data: 0x020000000300000000000000A4E51E5364647300D8C674AFC031228D64647300D8C674AFB8EC307B64647300262C333B\nPickUpSound: 08AB15:Immersive Sounds - Compendium.esp\nPutDownSound: 08AB16:Immersive Sounds - Compendium.esp\nRace: 013749:Skyrim.esm\nKeywords:\n- 06BBE9:Skyrim.esm\n- 08F95A:Skyrim.esm\n- 0A8664:Skyrim.esm\n- 10CD0A:Skyrim.esm\nArmature:\n- 09171F:Skyrim.esm\nValue: 485\nWeight: 0.5\n</code></pre><p></p> <p>This file is more palatable to Git and can support diff tools and similar functionality.</p> <p></p>"},{"location":"output/#mods-are-split-into-folders","title":"Mods are Split into Folders","text":"<p>Rather than having one large file of all of a mod's data, Spriggit splits a mod into a folder of files.</p> <p>A typical mod folder structure might look like: </p><pre><code>Some/Dedicated/Mod/Folder/  -  A folder dedicated to storing Spriggit content for a single mod\n   RecordData.yaml          -  The mod header\n   Weapons/                 -  Folder for all the weapons\n      GlassDagger.yaml      -  File dedicated to the record Glass Dagger\n      IronLongsword.yaml    -  Seperate file for the Iron Longsword\n   Npcs/                    -  Folder for all the weapons\n      Goblin.yaml           -  File dedicated to the Goblin's data\n</code></pre><p></p> <p></p> <p>This folder structure helps organize git diffs to be more meaningful.  If a new record is added, then this will be seen as a new file.   If a record is modified, it will be a modified file.   Similar to wanting to avoid having a program's code be in one large monolith file, having smaller bite sized files helps navigate and digest changes being made.</p>"},{"location":"sorting/","title":"Sorting","text":""},{"location":"sorting/#sorting","title":"Sorting","text":""},{"location":"sorting/#overview","title":"Overview","text":"<p>The Creation Kit automatically shuffles certain properties when saving plugin files. This behavior can cause instability in version control systems, as the same data may be stored in different orders across different save operations, leading to unnecessary differences in your Git history.</p> <p>Spriggit automatically sorts these known shuffled categories to ensure they remain stable from translation to translation.</p>"},{"location":"sorting/#why-sorting-matters","title":"Why Sorting Matters","text":"<p>When working with Git and tracking changes to your mod:</p> <ul> <li>Cleaner Diffs: Without sorting, the Creation Kit's shuffling would show every affected property as \"changed\" even when the actual data is identical</li> <li>Meaningful History: Your Git history will only show actual changes you made, not random reorderings from the Creation Kit</li> <li>Better Merges: Consistent ordering makes Git's merge algorithms more effective when combining changes from multiple contributors</li> <li>Reduced Conflicts: Stable ordering minimizes false merge conflicts that would otherwise occur from random shuffling</li> </ul>"},{"location":"sorting/#what-gets-sorted","title":"What Gets Sorted","text":"<p>Spriggit tracks and sorts various record properties that the Creation Kit is known to shuffle. This includes many list-type fields and collections within records.</p> <p>The sorting logic is continuously maintained and updated as new shuffling behaviors are discovered.</p>"},{"location":"sorting/#reporting-new-shuffle-cases","title":"Reporting New Shuffle Cases","text":"<p>If you notice fields in your Spriggit output that are still being shuffled between translations (appearing as changes in Git when you haven't actually modified them), please report them to the Spriggit GitHub repository as issues.</p> <p>When reporting:</p> <ol> <li>Specify which game (Skyrim, Fallout 4, etc.)</li> <li>Identify the record type (Quest, NPC, etc.)</li> <li>Note which specific field or property is being shuffled</li> </ol> <p>This helps improve Spriggit for everyone by ensuring all known shuffle cases are handled.</p>"},{"location":"spriggit-file/","title":".spriggit File","text":""},{"location":"spriggit-file/#spriggit-file","title":".spriggit File","text":"<p>By default, the Translation Package and Version to use is set by the user when doing the translation call (either by UI or CMD).   In environments with multiple developers, though, this might be undesirable as each developer might choose different settings when working.</p> <p>A dedicated <code>.spriggit</code> file can be defined at or above the spriggit folder in the repository, which provides a centralized location that the package details can be set.  These specifications are automatically picked up and used by Spriggit, keeping the settings coordinated even with many developers.</p>"},{"location":"spriggit-file/#creating","title":"Creating","text":"<p>Right now the only way to make this file is by hand, but it is fairly trivial.</p> <p>Create a file named <code>.spriggit</code> with the desired content in this format: </p><pre><code>{\n  \"PackageName\": \"Spriggit.Yaml\",\n  \"Release\": \"Starfield\",\n  \"Version\": \"0.18\"\n}\n</code></pre><p></p> <p> Game Releases</p> <p>This file should be next to, or above the Spriggit mod folder(s) you want it to affect.</p>"},{"location":"spriggit-file/#updating","title":"Updating","text":"<p>To update to a different version, simply modify the file to the desired version, and then run any spriggit commands.</p>"},{"location":"spriggit-file/#known-masters","title":"Known Masters","text":"<p><code>.spriggit</code> files can also supply extra information to help with Starfield translations in the form of Known Masters.</p> <p>Since Starfield requires extra information about all listed masters, typically it needs those master files present so they can be read in and referenced.   However, when running Spriggit translations on a server, those master files might not be available.</p> <p>In situations like these, you can list the master files and their \"Master Style\" within a <code>.spriggit</code> file to provide the necessary information, without the actual master mod files needing to be present.</p> <pre><code>{\n   \"KnownMasters\": \n   [\n       {\n           \"ModKey\": \"Starfield.esm\",\n           \"Style\": \"Full\"\n       }\n   ]\n}\n</code></pre> <p>Where the options are:</p> <ul> <li>Full</li> <li>Medium</li> <li>Small</li> </ul> <p>These correspond to the type of master the file it is, and the FormID master index patterns it was saved with.</p>"},{"location":"translation-packages/","title":"Translation Packages","text":""},{"location":"translation-packages/#spriggit-translation-packages","title":"Spriggit Translation Packages","text":"<p>The logic for actually doing the translation is not housed or packaged directly with the CLI or UI.   Rather, the logic exists in NuGet packages that are downloaded and then used to do the translation.</p> <p>These are typically <code>Spriggit.Yaml</code> and <code>Spriggit.Json</code>, which are the two suites of Translation Packages that the Spriggit project itself provides.  A NuGet listing for one of them can be seen here.</p>"},{"location":"translation-packages/#mechanics","title":"Mechanics","text":"<p>When Spriggit is asked to do a serialization from a Bethesda plugin file to text format, it takes the supplied Nuget package name and version and downloads that package.  It then uses the libraries within that package to do the translations.</p> <p>As such, a Spriggit CLI/UI can translate to/from many different translation formats/styles, rather than being bound to the translation logic that existed when the CLI/UI was built.</p>"},{"location":"translation-packages/#reasoning","title":"Reasoning","text":"<p>This separation is an important aspect of keeping Spriggit flexible as record definitions evolve.   </p> <p>Especially early on during a game's release, the record definitions are constantly being upgraded, adjusted, and fixed.  The separation allows Spriggit to always grab the older version of a translation, and use that to deserialize text that contains older definitions.</p> <p>If very old versions get deserialized, the older nuget packages will be downloaded and used to read them.   And, if the user re-serializes them with the latest nuget packages, they will be \"upgraded\" to the latest text definitions.</p>"},{"location":"translation-packages/#example","title":"Example","text":"<p>Let's take a simple example of a typo.   Let's say <code>Haelth</code> was accidentally used as a field name in <code>v1.1</code> of Spriggit, and a plugin was serialized into text with that typo. Eventually someone notices, and fixes it to <code>Health</code> in <code>v1.2</code>.  How does the old file that contained <code>Haelth</code> get properly read anymore?</p> <p>It will be able to be read, because the original file will have been stamped with <code>v1.1</code>.  During deserialization of the file, Spriggit will see that and download that <code>v1.1</code> nuget package, and use that to read the file.   The <code>Haelth</code> field will be read in as expected by the <code>v1.1</code> package, yielding a proper esp output.</p>"},{"location":"translation-packages/#customization","title":"Customization","text":"<p>Spriggit uses Mutagen systems under the hood, and leans on the Mutagen.Bethesda.Serialization library to convert to/from Yaml and Json.</p> <p>One of the features of Mutagen.Bethesda.Serialization is that it allows for customization of naming, file structure, and other similar things.   If you utilize this to make your own customization, you will need to upload the results to nuget.org for people to grab and use.</p> <p>More documentation will follow on how to upload your own customization package to Nuget so that it can be used by Spriggit.    For now, two packages exist \"built in\":</p> <ul> <li><code>Spriggit.Yaml.[GameName]</code></li> <li><code>Spriggit.Json.[GameName]</code></li> </ul> <p>These are what will be used to do any translations, unless the user specifies the name of a customization package they wish to use instead.</p>"},{"location":"unexpected-records/","title":"Unexpected Records","text":""},{"location":"unexpected-records/#unexpected-records","title":"Unexpected Records","text":"<p>Especially in the early days of a new game, you might see Spriggit refuse to serialize a mod with the verbage of \"unexpected records\".</p> <p>This is intentional as a safety mechanism to help avoid data loss.   If Spriggit encounters a record that it is unsure of, it refuses to proceed, rather than skip the record.</p>"},{"location":"unexpected-records/#solution","title":"Solution","text":"<p>Running into this error usually means that Spriggit's definitions need to be updated.  You can report unexpected records to the Spriggit or Mutagen Github issues.</p> <p>Please include as much detail as you can in the report, including:</p> <ul> <li>The subrecord in question that it complained about (usually printed in the logs or console)</li> <li>Information about what tools went into making the mod.  Did you just use the official CK?  Or did you use other 3rd party tools?</li> <li>The source file (if you're willing to give it)</li> </ul> <p>With that info, Spriggit's definitions should hopefully get updated quickly in a new published version, and you'll be on your way.  The mechanisms are meant to be upgraded frequently in this way.</p> <p>Feel free to stop by the Discord to chat more directly!</p> <p></p>"},{"location":"upgrade-practices/","title":"Upgrade Spriggit Versions","text":""},{"location":"upgrade-practices/#upgrade-spriggit-version-in-dedicated-commits","title":"Upgrade Spriggit Version in Dedicated Commits","text":"<p>When upgrading your Spriggit translation package to a newer version, it's strongly recommended to do this in a dedicated commit that only contains the upgrade changes.</p>"},{"location":"upgrade-practices/#why-this-matters","title":"Why This Matters","text":"<ul> <li>Isolates upgrade diffs: Version upgrades can cause formatting changes, improved serialization, or other structural modifications to your text files that are unrelated to your actual mod changes</li> <li>Prevents ambush diffs: By upgrading and committing immediately, you avoid unexpected and unrelated file changes appearing in future commits when you're working on actual mod content</li> <li>Cleaner git history: Makes it easier to review what changes are due to the upgrade versus actual mod modifications</li> <li>Easier troubleshooting: If issues arise, you can easily identify whether they're related to the upgrade or your mod changes</li> </ul>"},{"location":"upgrade-practices/#recommended-workflows","title":"Recommended Workflows","text":"<p>There are two approaches to upgrading Spriggit versions:</p>"},{"location":"upgrade-practices/#cli-workflow","title":"CLI Workflow","text":"<ol> <li> <p>Upgrade the version using the <code>upgrade</code> command:    </p><pre><code>.\\Path\\To\\Spriggit.CLI.exe upgrade -p \"C:\\MyGitRepository\\SomeMod.esp\\\" -v \"1.2.3\"\n</code></pre><p></p> </li> <li> <p>Review the changes to understand what the upgrade modified:    </p><pre><code>git diff\n</code></pre><p></p> </li> <li> <p>Commit immediately with a clear message:    </p><pre><code>git add -A\ngit commit -m \"Upgrade Spriggit to version 1.2.3\"\n</code></pre><p></p> </li> <li> <p>Continue with your mod work in subsequent commits, knowing that any future diffs will be related to your actual changes</p> </li> </ol>"},{"location":"upgrade-practices/#manual-workflow","title":"Manual Workflow","text":"<ol> <li> <p>Update the spriggit-meta.json file to specify the new version:    </p><pre><code>{\n  \"Source\": {\n    \"PackageName\": \"Spriggit.Yaml.Skyrim\",\n    \"Version\": \"1.2.3\"\n  }\n}\n</code></pre><p></p> </li> <li> <p>Re-serialize with new version back to the repository:    </p><pre><code>.\\Path\\To\\Spriggit.CLI.exe serialize -i \"C:\\Temp\\SomeMod.esp\" -o \"C:\\MyGitRepository\\SomeMod.esp\\\"\n</code></pre>    Or use the UI, if that is what you're using.<p></p> </li> <li> <p>Review and commit the changes:    </p><pre><code>git diff\ngit add -A\ngit commit -m \"Upgrade Spriggit to version 1.2.3\"\n</code></pre><p></p> </li> </ol> <p>Don't Mix Changes</p> <p>Avoid making mod changes in the same commit as a Spriggit version upgrade, as this makes it difficult to distinguish between upgrade-related changes and your actual modifications.</p>"},{"location":"workflow/","title":"Workflow","text":""},{"location":"workflow/#workflow","title":"Workflow","text":"<p>This area discusses the typical patterns for using Spriggit in your workflow.</p>"},{"location":"workflow/#an-individual-modder","title":"An Individual Modder","text":"<ul> <li>Create a Git Repository to hold your mod</li> <li>Create a Bethesda plugin with existing normal tools of choice</li> <li>Use Spriggit to convert the <code>.esp/m/l</code> files from your Bethesda workspace, to <code>.yaml</code> or <code>.json</code> files inside your Git Repository</li> <li>Make commits in Git.   \"Added all the bandit Npc definitions\"   \"Fixed the Powerblade damage to be more reasonable\"</li> <li>Upload your mod, in its text format, up to Github (or your host of preference)</li> </ul>"},{"location":"workflow/#many-collaborators","title":"Many Collaborators","text":"<p>Other modders, whether on your team or just helpful people out in the world can help collaborate and participate in your mod's development.</p> <ul> <li>They can clone the mod via Git to their computers</li> <li>Use Spriggit to convert from the <code>.yaml</code> or <code>.json</code> files to a Bethesda plugin</li> <li>Open the Bethesda plugin with the game, or other tools</li> <li>Modify the mod and help work on something</li> <li>Use Spriggit to convert back to text format</li> <li>Make commits in Git</li> <li>Upload their improvements to Github</li> <li>Initiate a Pull Request to ask that you consider their changes</li> <li>You can discuss with them about further changes, or merge their improvements into your mod</li> </ul>"}]}